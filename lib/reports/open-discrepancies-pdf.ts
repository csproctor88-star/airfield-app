import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'
import type { OpenDiscrepanciesData, PhotoForReport } from './open-discrepancies-data'
import { formatDiscrepancyType } from './open-discrepancies-data'

interface Options {
  generatedBy: string
  includeNotes: boolean
}

const STATUS_LABELS: Record<string, string> = {
  submitted_to_afm: 'Submitted to AFM',
  submitted_to_ces: 'Submitted to CES',
  awaiting_action_by_ces: 'Awaiting CES Action',
  work_completed_awaiting_verification: 'Awaiting Verification',
  open: 'Open',
}

export function generateOpenDiscrepanciesPdf(data: OpenDiscrepanciesData, opts: Options) {
  const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'letter' })
  const pageWidth = doc.internal.pageSize.getWidth()
  const pageHeight = doc.internal.pageSize.getHeight()
  const margin = 12
  const contentWidth = pageWidth - margin * 2
  let y = margin
  let pageNum = 1

  function addPageNumber() {
    doc.setFontSize(8)
    doc.setTextColor(150)
    doc.text(`Page ${pageNum}`, pageWidth / 2, pageHeight - 6, { align: 'center' })
  }

  function checkPageBreak(needed: number) {
    if (y + needed > pageHeight - 14) {
      addPageNumber()
      doc.addPage()
      pageNum++
      y = margin
    }
  }

  function sectionHeader(title: string) {
    checkPageBreak(14)
    doc.setFontSize(10)
    doc.setFont('helvetica', 'bold')
    doc.setTextColor(0)
    doc.text(title, margin, y)
    y += 1
    doc.setDrawColor(0)
    doc.setLineWidth(0.4)
    doc.line(margin, y, margin + contentWidth, y)
    y += 5
    doc.setFont('helvetica', 'normal')
  }

  // ── HEADER ──
  doc.setFontSize(8)
  doc.setTextColor(100)
  doc.text('GLIDEPATH', margin, y)
  y += 5

  doc.setFontSize(14)
  doc.setTextColor(0)
  doc.setFont('helvetica', 'bold')
  doc.text('OPEN DISCREPANCIES REPORT', margin, y)
  y += 6

  doc.setFontSize(10)
  doc.setFont('helvetica', 'normal')
  doc.text('Selfridge ANGB (KMTC)', margin, y)
  y += 5

  doc.setFontSize(9)
  doc.setTextColor(60)
  const now = new Date()
  doc.text(`As of: ${now.toLocaleString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' })}`, margin, y)
  y += 4
  doc.text(`Generated by: ${opts.generatedBy}`, margin, y)
  y += 4
  doc.text(`Total Open: ${data.summary.total}`, margin, y)
  if (data.summary.agingOver30 > 0) {
    doc.text(`   |   > 30 Days: ${data.summary.agingOver30}`, margin + 40, y)
  }
  y += 7

  // ── SUMMARY STATISTICS ──
  sectionHeader('SUMMARY')

  // By Area
  const areaEntries = Object.entries(data.summary.byArea).sort((a, b) => b[1] - a[1])
  if (areaEntries.length > 0) {
    doc.setFontSize(9)
    doc.setTextColor(0)
    const areaText = 'By Area: ' + areaEntries.map(([a, c]) => `${a} (${c})`).join(', ')
    const areaLines = doc.splitTextToSize(areaText, contentWidth)
    doc.text(areaLines, margin, y)
    y += areaLines.length * 4
  }

  // By Type
  const typeEntries = Object.entries(data.summary.byType).sort((a, b) => b[1] - a[1])
  if (typeEntries.length > 0) {
    doc.setFontSize(9)
    const typeText = 'By Type: ' + typeEntries.map(([t, c]) => `${formatDiscrepancyType(t)} (${c})`).join(', ')
    const typeLines = doc.splitTextToSize(typeText, contentWidth)
    doc.text(typeLines, margin, y)
    y += typeLines.length * 4
  }
  y += 3

  // ── DISCREPANCY ENTRIES ──
  // Sort by days open descending (oldest first)
  const sorted = [...data.discrepancies].sort((a, b) => b.days_open - a.days_open)

  sectionHeader('ALL OPEN DISCREPANCIES')

  // Render each discrepancy as a table row with inline photo thumbnails
  const tableBody = sorted.map((d) => {
    const reporter = d.reporter_rank ? `${d.reporter_rank} ${d.reporter_name}` : d.reporter_name
    const lastUpdate = d.last_update_at
      ? new Date(d.last_update_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
      : '—'
    return [
      d.display_id,
      d.title,
      formatDiscrepancyType(d.type),
      d.location_text,
      d.work_order_number || '—',
      STATUS_LABELS[d.current_status] || d.current_status,
      d.days_open.toString(),
      reporter,
      lastUpdate,
      '', // Photos rendered via didDrawCell
    ]
  })

  const discPhotos = sorted.map((d) => data.photos[d.id] || [])

  autoTable(doc, {
    startY: y,
    margin: { left: margin, right: margin },
    head: [['ID', 'Title', 'Type', 'Location', 'W/O #', 'Status', 'Days', 'Reported By', 'Last Update', 'Photos']],
    body: tableBody,
    styles: { fontSize: 7, cellPadding: 1.5, textColor: [0, 0, 0] },
    headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
    alternateRowStyles: { fillColor: [245, 245, 245] },
    columnStyles: {
      0: { cellWidth: 20 },
      1: { cellWidth: 35 },
      6: { cellWidth: 10, halign: 'center' },
      9: { cellWidth: 40 },
    },
    didParseCell: (hookData) => {
      if (hookData.section !== 'body') return
      const rowIdx = hookData.row.index
      const disc = sorted[rowIdx]
      if (!disc) return

      // Bold + red for >30 days
      if (disc.days_open > 30 && hookData.column.index === 6) {
        hookData.cell.styles.textColor = [220, 38, 38]
        hookData.cell.styles.fontStyle = 'bold'
      }

      // Set row height for photos
      if (hookData.column.index === 9) {
        const photos = discPhotos[rowIdx] || []
        if (photos.length > 0) {
          hookData.cell.styles.minCellHeight = OD_PHOTO_THUMB_H + 4
        }
      }
    },
    didDrawCell: (hookData) => {
      if (hookData.section === 'body' && hookData.column.index === 9) {
        const photos = discPhotos[hookData.row.index] || []
        drawPhotosInCell(doc, photos, hookData.cell.x, hookData.cell.y, hookData.cell.width)
      }
    },
  })
  y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 6

  // ── INLINE DETAILS PER DISCREPANCY (notes only — photos are now in the table) ──
  if (opts.includeNotes) {
    for (const disc of sorted) {
      const notes = data.notesHistory[disc.id] || []
      if (notes.length === 0) continue

      checkPageBreak(20)

      // Discrepancy header
      doc.setFontSize(9)
      doc.setFont('helvetica', 'bold')
      doc.setTextColor(0)
      doc.text(`${disc.display_id} — ${disc.title}`, margin, y)
      doc.setFont('helvetica', 'normal')
      y += 4

      // Metadata line
      doc.setFontSize(7)
      doc.setTextColor(80)
      doc.text(`Type: ${formatDiscrepancyType(disc.type)}  |  Location: ${disc.location_text}  |  NOTAM: ${disc.notam_reference || 'None'}`, margin + 2, y)
      y += 4

      // Description
      if (disc.description) {
        doc.setFontSize(7)
        doc.setFont('helvetica', 'bold')
        doc.setTextColor(60)
        doc.text('Description:', margin + 2, y)
        doc.setFont('helvetica', 'normal')
        y += 3
        const descLines = doc.splitTextToSize(disc.description, contentWidth - 6)
        doc.text(descLines, margin + 4, y)
        y += descLines.length * 3 + 1
      }

      // Notes history (as table — all data in a single row per note)
      doc.setFontSize(7)
      doc.setFont('helvetica', 'bold')
      doc.setTextColor(60)
      doc.text('Notes History:', margin + 2, y)
      doc.setFont('helvetica', 'normal')
      y += 4

      const notesTableBody = notes.map((note) => {
        const name = note.user_rank ? `${note.user_rank} ${note.user_name}` : note.user_name
        const time = new Date(note.created_at).toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })
        const statusChange = note.old_status && note.new_status
          ? `${STATUS_LABELS[note.old_status] || note.old_status} → ${STATUS_LABELS[note.new_status] || note.new_status}`
          : '—'
        return [time, name, statusChange, note.notes || '—']
      })

      autoTable(doc, {
        startY: y,
        margin: { left: margin + 2, right: margin },
        head: [['Date', 'By', 'Status Change', 'Note']],
        body: notesTableBody,
        styles: { fontSize: 6.5, cellPadding: 1.5, textColor: [0, 0, 0] },
        headStyles: { fillColor: [51, 65, 85], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 6.5 },
        alternateRowStyles: { fillColor: [248, 250, 252] },
        columnStyles: {
          0: { cellWidth: 30 },
          1: { cellWidth: 35 },
          2: { cellWidth: 45 },
        },
      })
      y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 3

      // Divider between discrepancies
      doc.setDrawColor(220)
      doc.setLineWidth(0.2)
      doc.line(margin, y, margin + contentWidth, y)
      y += 4
    }
  }

  // Footer
  addPageNumber()

  // Save
  const dateStr = now.toISOString().split('T')[0]
  doc.save(`KMTC_Open_Discrepancies_${dateStr}.pdf`)
}

// ── Photo rendering helper ──

const OD_PHOTO_THUMB_W = 20 // mm
const OD_PHOTO_THUMB_H = 15 // mm (4:3 ratio)
const OD_PHOTO_GAP = 1.5 // mm

function drawPhotosInCell(
  doc: jsPDF,
  photos: PhotoForReport[],
  cellX: number,
  cellY: number,
  cellWidth: number,
) {
  if (photos.length === 0) return

  const padding = 2
  const availableWidth = cellWidth - padding * 2
  const thumbsPerRow = Math.max(1, Math.floor(availableWidth / (OD_PHOTO_THUMB_W + OD_PHOTO_GAP)))
  let xOffset = cellX + padding
  let yOffset = cellY + padding

  for (let i = 0; i < photos.length; i++) {
    if (i > 0 && i % thumbsPerRow === 0) {
      yOffset += OD_PHOTO_THUMB_H + OD_PHOTO_GAP
      xOffset = cellX + padding
    }

    const photo = photos[i]
    if (photo.dataUrl) {
      try {
        const format = photo.dataUrl.includes('image/png') ? 'PNG' : 'JPEG'
        doc.addImage(photo.dataUrl, format, xOffset, yOffset, OD_PHOTO_THUMB_W, OD_PHOTO_THUMB_H)
      } catch {
        doc.setDrawColor(180)
        doc.rect(xOffset, yOffset, OD_PHOTO_THUMB_W, OD_PHOTO_THUMB_H)
        doc.setFontSize(5)
        doc.setTextColor(150)
        doc.text('img', xOffset + 2, yOffset + OD_PHOTO_THUMB_H / 2)
      }
    } else {
      doc.setDrawColor(180)
      doc.rect(xOffset, yOffset, OD_PHOTO_THUMB_W, OD_PHOTO_THUMB_H)
      doc.setFontSize(5)
      doc.setTextColor(150)
      doc.text('img', xOffset + 2, yOffset + OD_PHOTO_THUMB_H / 2)
    }

    xOffset += OD_PHOTO_THUMB_W + OD_PHOTO_GAP
  }
}
