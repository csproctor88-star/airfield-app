import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'
import type { DailyReportData } from './daily-ops-data'

interface Options {
  startDate: string
  endDate: string
  isRange: boolean
  generatedBy: string
}

const CHECK_TYPE_LABELS: Record<string, string> = {
  fod: 'FOD', rsc: 'RSC', rcr: 'RCR', bash: 'BASH',
  ife: 'In-Flight Emergency', ground_emergency: 'Ground Emergency', heavy_aircraft: 'Heavy Aircraft',
}

const INSPECTION_TYPE_LABELS: Record<string, string> = {
  airfield: 'Airfield Inspection', lighting: 'Lighting Inspection',
  construction_meeting: 'Construction Meeting', joint_monthly: 'Joint Monthly',
}

const STATUS_LABELS: Record<string, string> = {
  submitted_to_afm: 'Submitted to AFM',
  submitted_to_ces: 'Submitted to CES',
  awaiting_action_by_ces: 'Awaiting CES Action',
  work_completed_awaiting_verification: 'Awaiting Verification',
  open: 'Open',
  completed: 'Completed',
  cancelled: 'Cancelled',
}

function fmtTime(iso: string) {
  return new Date(iso).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
}

function fmtDatePdf(dateStr: string) {
  return new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', { day: '2-digit', month: 'short', year: 'numeric' })
}

export function generateDailyOpsPdf(data: DailyReportData, opts: Options) {
  const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'letter' })
  const pageWidth = doc.internal.pageSize.getWidth()
  const pageHeight = doc.internal.pageSize.getHeight()
  const margin = 15
  const contentWidth = pageWidth - margin * 2
  let y = margin
  let pageNum = 1

  function addPageNumber() {
    doc.setFontSize(8)
    doc.setTextColor(150)
    doc.text(`Page ${pageNum}`, pageWidth / 2, pageHeight - 8, { align: 'center' })
  }

  function checkPageBreak(needed: number) {
    if (y + needed > pageHeight - 18) {
      addPageNumber()
      doc.addPage()
      pageNum++
      y = margin
    }
  }

  function sectionHeader(title: string) {
    checkPageBreak(14)
    doc.setFontSize(10)
    doc.setFont('helvetica', 'bold')
    doc.setTextColor(0)
    doc.text(title, margin, y)
    y += 1
    doc.setDrawColor(0)
    doc.setLineWidth(0.4)
    doc.line(margin, y, margin + contentWidth, y)
    y += 5
    doc.setFont('helvetica', 'normal')
  }

  function emptyState(text: string) {
    doc.setFontSize(9)
    doc.setTextColor(120)
    doc.text(text, margin, y)
    y += 6
  }

  // ── HEADER ──
  doc.setFontSize(8)
  doc.setTextColor(100)
  doc.text('GLIDEPATH', margin, y)
  y += 5

  doc.setFontSize(14)
  doc.setTextColor(0)
  doc.setFont('helvetica', 'bold')
  doc.text('DAILY AIRFIELD OPERATIONS SUMMARY', margin, y)
  y += 6

  doc.setFontSize(10)
  doc.setFont('helvetica', 'normal')
  doc.text('Selfridge ANGB (KMTC)', margin, y)
  y += 5

  doc.setFontSize(9)
  doc.setTextColor(60)
  const dateLabel = opts.isRange
    ? `${fmtDatePdf(opts.startDate)} — ${fmtDatePdf(opts.endDate)}`
    : fmtDatePdf(opts.startDate)
  doc.text(`Date: ${dateLabel}`, margin, y)
  y += 4
  doc.text(`Generated by: ${opts.generatedBy}`, margin, y)
  y += 4
  doc.text(`Generated: ${new Date().toLocaleString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' })}`, margin, y)
  y += 8

  // ── 1. INSPECTIONS ──
  sectionHeader('AIRFIELD & LIGHTING INSPECTIONS')

  if (data.inspections.length === 0) {
    emptyState('No airfield/lighting inspection recorded for this date.')
  } else {
    for (const insp of data.inspections) {
      checkPageBreak(20)
      const typeLabel = INSPECTION_TYPE_LABELS[insp.inspection_type] || insp.inspection_type
      const completedBy = insp.completed_by_name || insp.inspector_name || 'Unknown'
      const time = insp.completed_at ? fmtTime(insp.completed_at) : ''
      const result = insp.failed_count > 0
        ? `${insp.passed_count}/${insp.total_items} passed, ${insp.failed_count} failure${insp.failed_count !== 1 ? 's' : ''}`
        : `${insp.passed_count}/${insp.total_items} items passed`

      doc.setFontSize(9)
      doc.setFont('helvetica', 'bold')
      doc.setTextColor(0)
      doc.text(`${typeLabel} — COMPLETED`, margin + 2, y)
      doc.setFont('helvetica', 'normal')
      y += 4
      doc.setTextColor(60)
      doc.text(`Conducted by: ${completedBy}${time ? `, ${time}` : ''}`, margin + 2, y)
      y += 4
      doc.text(`Result: ${result}`, margin + 2, y)
      y += 4

      // List failed items
      const failedItems = (insp.items || []).filter((i) => i.response === 'fail')
      if (failedItems.length > 0) {
        doc.setFontSize(8)
        doc.setTextColor(180, 0, 0)
        doc.text('Failures:', margin + 2, y)
        y += 4
        for (const item of failedItems) {
          checkPageBreak(5)
          const notes = item.notes ? ` — ${item.notes}` : ''
          const text = `  - ${item.section}: ${item.item}${notes}`
          const lines = doc.splitTextToSize(text, contentWidth - 6)
          doc.text(lines, margin + 4, y)
          y += lines.length * 3.5
        }
        doc.setTextColor(0)
      }
      y += 3
    }
  }

  // ── 2. COMPLETED CHECKS ──
  sectionHeader('COMPLETED CHECKS')

  if (data.checks.length === 0) {
    emptyState('No checks recorded for this date.')
  } else {
    const tableBody = data.checks.map((c) => [
      CHECK_TYPE_LABELS[c.check_type] || c.check_type,
      c.completed_at ? fmtTime(c.completed_at) : '',
      c.completed_by || 'Unknown',
      (c.areas || []).join(', ') || '—',
      c.photo_count > 0 ? `${c.photo_count} photo${c.photo_count !== 1 ? 's' : ''}` : '',
    ])

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['Type', 'Time', 'Conducted By', 'Area(s)', 'Photos']],
      body: tableBody,
      styles: { fontSize: 8, cellPadding: 2, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // ── 3. RUNWAY STATUS CHANGES ──
  sectionHeader('RUNWAY STATUS CHANGES & ADVISORIES')

  if (data.runwayChanges.length === 0) {
    emptyState('No runway status changes for this date.')
  } else {
    const tableBody = data.runwayChanges.map((r) => {
      const time = fmtTime(r.created_at)
      const statusChange = r.old_runway_status !== r.new_runway_status
        ? `${r.old_runway_status} → ${r.new_runway_status}`
        : '—'
      const runwayChange = r.old_active_runway !== r.new_active_runway
        ? `RWY ${r.old_active_runway} → ${r.new_active_runway}`
        : ''
      const change = [statusChange, runwayChange].filter(Boolean).join('; ')
      const name = r.user_rank ? `${r.user_rank} ${r.user_name}` : (r.user_name || 'Unknown')
      return [time, change, name, r.reason || '—']
    })

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['Time', 'Change', 'Changed By', 'Reason']],
      body: tableBody,
      styles: { fontSize: 8, cellPadding: 2, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // ── 4. NEW DISCREPANCIES ──
  sectionHeader(`NEW DISCREPANCIES (${data.newDiscrepancies.length})`)

  if (data.newDiscrepancies.length === 0) {
    emptyState('No new discrepancies reported for this date.')
  } else {
    const tableBody = data.newDiscrepancies.map((d) => {
      const reporter = d.reporter_rank ? `${d.reporter_rank} ${d.reporter_name}` : d.reporter_name
      return [d.display_id, d.title, d.type, d.location_text, d.severity, d.assigned_shop || '—', reporter]
    })

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['ID', 'Title', 'Type', 'Location', 'Severity', 'Shop', 'Reported By']],
      body: tableBody,
      styles: { fontSize: 7, cellPadding: 1.5, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      columnStyles: {
        0: { cellWidth: 22 },
        1: { cellWidth: 35 },
        4: { cellWidth: 16 },
      },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // ── 5. UPDATED DISCREPANCIES ──
  const uniqueUpdatedDiscs = new Set(data.statusUpdates.map((u) => u.discrepancy_id))
  sectionHeader(`DISCREPANCY UPDATES (${data.statusUpdates.length} update${data.statusUpdates.length !== 1 ? 's' : ''} across ${uniqueUpdatedDiscs.size} discrepanc${uniqueUpdatedDiscs.size !== 1 ? 'ies' : 'y'})`)

  if (data.statusUpdates.length === 0) {
    emptyState('No discrepancy updates for this date.')
  } else {
    const tableBody = data.statusUpdates.map((u) => {
      const statusChange = u.old_status && u.new_status
        ? `${STATUS_LABELS[u.old_status] || u.old_status} → ${STATUS_LABELS[u.new_status] || u.new_status}`
        : u.new_status ? STATUS_LABELS[u.new_status] || u.new_status : '—'
      const name = u.user_rank ? `${u.user_rank} ${u.user_name}` : u.user_name
      return [u.discrepancy_display_id, u.discrepancy_title, statusChange, u.notes || '—', name, fmtTime(u.created_at)]
    })

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['ID', 'Title', 'Status Change', 'Notes', 'Updated By', 'Time']],
      body: tableBody,
      styles: { fontSize: 7, cellPadding: 1.5, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      columnStyles: {
        0: { cellWidth: 22 },
        3: { cellWidth: 35 },
      },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // ── 6. OBSTRUCTION EVALUATIONS ──
  sectionHeader('OBSTRUCTION EVALUATIONS')

  if (data.obstructionEvals.length === 0) {
    emptyState('No obstruction evaluations recorded for this date.')
  } else {
    const tableBody = data.obstructionEvals.map((e) => {
      const result = e.has_violation ? 'VIOLATION' : 'CLEAR'
      const name = e.evaluator_rank ? `${e.evaluator_rank} ${e.evaluator_name}` : e.evaluator_name
      const surfaces = e.has_violation ? (e.violated_surfaces || []).length.toString() : '—'
      return [e.display_id, e.description || '—', `${e.object_height_agl} ft AGL`, result, e.controlling_surface || '—', surfaces, name]
    })

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['ID', 'Description', 'Height', 'Result', 'Controlling Surface', 'Violations', 'Evaluated By']],
      body: tableBody,
      styles: { fontSize: 7, cellPadding: 1.5, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      didParseCell: (hookData) => {
        // Highlight VIOLATION in red
        if (hookData.section === 'body' && hookData.column.index === 3) {
          const val = hookData.cell.raw as string
          if (val === 'VIOLATION') {
            hookData.cell.styles.textColor = [220, 38, 38]
            hookData.cell.styles.fontStyle = 'bold'
          }
        }
      },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // Footer
  addPageNumber()

  // Save
  const dateSuffix = opts.isRange
    ? `${opts.startDate}_to_${opts.endDate}`
    : opts.startDate
  doc.save(`KMTC_Daily_Ops_${dateSuffix}.pdf`)
}
