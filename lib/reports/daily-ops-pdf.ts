import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'
import type { DailyReportData, PhotoForDailyReport } from './daily-ops-data'
import { formatDiscrepancyType } from './open-discrepancies-data'

interface Options {
  startDate: string
  endDate: string
  isRange: boolean
  generatedBy: string
}

const CHECK_TYPE_LABELS: Record<string, string> = {
  fod: 'FOD', rsc: 'RSC', rcr: 'RCR', bash: 'BASH',
  ife: 'In-Flight Emergency', ground_emergency: 'Ground Emergency', heavy_aircraft: 'Heavy Aircraft',
}

const INSPECTION_TYPE_LABELS: Record<string, string> = {
  airfield: 'Airfield Inspection', lighting: 'Lighting Inspection',
  construction_meeting: 'Construction Meeting', joint_monthly: 'Joint Monthly',
}

const STATUS_LABELS: Record<string, string> = {
  submitted_to_afm: 'Submitted to AFM',
  submitted_to_ces: 'Submitted to CES',
  awaiting_action_by_ces: 'Awaiting CES Action',
  work_completed_awaiting_verification: 'Awaiting Verification',
  open: 'Open',
  completed: 'Completed',
  cancelled: 'Cancelled',
}

function fmtTime(iso: string) {
  return new Date(iso).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
}

function fmtDatePdf(dateStr: string) {
  return new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', { day: '2-digit', month: 'short', year: 'numeric' })
}

export function generateDailyOpsPdf(data: DailyReportData, opts: Options) {
  const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'letter' })
  const pageWidth = doc.internal.pageSize.getWidth()
  const pageHeight = doc.internal.pageSize.getHeight()
  const margin = 15
  const contentWidth = pageWidth - margin * 2
  let y = margin
  let pageNum = 1

  function addPageNumber() {
    doc.setFontSize(8)
    doc.setTextColor(150)
    doc.text(`Page ${pageNum}`, pageWidth / 2, pageHeight - 8, { align: 'center' })
  }

  function checkPageBreak(needed: number) {
    if (y + needed > pageHeight - 18) {
      addPageNumber()
      doc.addPage()
      pageNum++
      y = margin
    }
  }

  function sectionHeader(title: string) {
    checkPageBreak(14)
    doc.setFontSize(10)
    doc.setFont('helvetica', 'bold')
    doc.setTextColor(0)
    doc.text(title, margin, y)
    y += 1
    doc.setDrawColor(0)
    doc.setLineWidth(0.4)
    doc.line(margin, y, margin + contentWidth, y)
    y += 5
    doc.setFont('helvetica', 'normal')
  }

  function emptyState(text: string) {
    doc.setFontSize(9)
    doc.setTextColor(120)
    doc.text(text, margin, y)
    y += 6
  }

  // ── HEADER ──
  doc.setFontSize(8)
  doc.setTextColor(100)
  doc.text('GLIDEPATH', margin, y)
  y += 5

  doc.setFontSize(14)
  doc.setTextColor(0)
  doc.setFont('helvetica', 'bold')
  doc.text('DAILY AIRFIELD OPERATIONS SUMMARY', margin, y)
  y += 6

  doc.setFontSize(10)
  doc.setFont('helvetica', 'normal')
  doc.text('Selfridge ANGB (KMTC)', margin, y)
  y += 5

  doc.setFontSize(9)
  doc.setTextColor(60)
  const dateLabel = opts.isRange
    ? `${fmtDatePdf(opts.startDate)} — ${fmtDatePdf(opts.endDate)}`
    : fmtDatePdf(opts.startDate)
  doc.text(`Date: ${dateLabel}`, margin, y)
  y += 4
  doc.text(`Generated by: ${opts.generatedBy}`, margin, y)
  y += 4
  doc.text(`Generated: ${new Date().toLocaleString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' })}`, margin, y)
  y += 8

  // ── 1. INSPECTIONS ──
  sectionHeader('AIRFIELD & LIGHTING INSPECTIONS')

  if (data.inspections.length === 0) {
    emptyState('No airfield/lighting inspection recorded for this date.')
  } else {
    for (const insp of data.inspections) {
      checkPageBreak(20)
      const typeLabel = INSPECTION_TYPE_LABELS[insp.inspection_type] || insp.inspection_type
      const completedBy = insp.completed_by_name || insp.inspector_name || 'Unknown'
      const time = insp.completed_at ? fmtTime(insp.completed_at) : ''
      const result = insp.failed_count > 0
        ? `${insp.passed_count}/${insp.total_items} passed, ${insp.failed_count} failure${insp.failed_count !== 1 ? 's' : ''}`
        : `${insp.passed_count}/${insp.total_items} items passed`

      doc.setFontSize(9)
      doc.setFont('helvetica', 'bold')
      doc.setTextColor(0)
      doc.text(`${typeLabel} — COMPLETED`, margin + 2, y)
      doc.setFont('helvetica', 'normal')
      y += 4
      doc.setTextColor(60)
      doc.text(`Conducted by: ${completedBy}${time ? `, ${time}` : ''}`, margin + 2, y)
      y += 4
      doc.text(`Result: ${result}`, margin + 2, y)
      y += 4

      // List failed items
      const failedItems = (insp.items || []).filter((i) => i.response === 'fail')
      if (failedItems.length > 0) {
        doc.setFontSize(8)
        doc.setTextColor(180, 0, 0)
        doc.text('Failures:', margin + 2, y)
        y += 4
        for (const item of failedItems) {
          checkPageBreak(5)
          const notes = item.notes ? ` — ${item.notes}` : ''
          const text = `  - ${item.section}: ${item.item}${notes}`
          const lines = doc.splitTextToSize(text, contentWidth - 6)
          doc.text(lines, margin + 4, y)
          y += lines.length * 3.5
        }
        doc.setTextColor(0)
      }
      y += 3
    }
  }

  // ── 2. COMPLETED CHECKS ──
  sectionHeader('COMPLETED CHECKS')

  if (data.checks.length === 0) {
    emptyState('No checks recorded for this date.')
  } else {
    const tableBody = data.checks.map((c) => [
      CHECK_TYPE_LABELS[c.check_type] || c.check_type,
      c.completed_at ? fmtTime(c.completed_at) : '',
      c.completed_by || 'Unknown',
      (c.areas || []).join(', ') || '—',
      '', // Photos rendered via didDrawCell
    ])

    // Build photo lookup for checks
    const checkPhotos = data.checks.map((c) => data.photos[`check:${c.id}`] || [])

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['Type', 'Time', 'Conducted By', 'Area(s)', 'Photos']],
      body: tableBody,
      styles: { fontSize: 8, cellPadding: 2, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      columnStyles: { 4: { cellWidth: 48 } },
      didParseCell: (hookData) => {
        if (hookData.section === 'body') {
          const photos = checkPhotos[hookData.row.index] || []
          if (photos.length > 0) {
            hookData.cell.styles.minCellHeight = PHOTO_THUMB_H + 4
          }
        }
      },
      didDrawCell: (hookData) => {
        if (hookData.section === 'body' && hookData.column.index === 4) {
          const photos = checkPhotos[hookData.row.index] || []
          drawPhotosInCell(doc, photos, hookData.cell.x, hookData.cell.y, hookData.cell.width)
        }
      },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // ── 3. CURRENT STATUS HISTORY ──
  sectionHeader('CURRENT STATUS HISTORY')

  // Build unified status history rows: runway, advisory, BWC, RSC
  type StatusHistoryRow = [string, string, string, string, string] // [Time, Category, Change, Changed By, Reason/Notes]
  const statusHistoryRows: StatusHistoryRow[] = []

  // Runway, Advisory changes from runway_status_log
  for (const r of data.runwayChanges) {
    const time = fmtTime(r.created_at)
    const name = r.user_rank ? `${r.user_rank} ${r.user_name}` : (r.user_name || 'Unknown')

    // Runway status change (always show — includes open/suspended/closed)
    if (r.new_runway_status) {
      const change = r.old_runway_status !== r.new_runway_status
        ? `${(r.old_runway_status || '').toUpperCase()} → ${(r.new_runway_status || '').toUpperCase()}`
        : `${(r.new_runway_status || '').toUpperCase()} (no change)`
      statusHistoryRows.push([time, 'Runway Status', change, name, r.reason || '—'])
    }

    // Active runway change
    if (r.old_active_runway !== r.new_active_runway) {
      const change = `RWY ${r.old_active_runway} → RWY ${r.new_active_runway}`
      statusHistoryRows.push([time, 'Active Runway', change, name, r.reason || '—'])
    }

    // Advisory change
    if (r.old_advisory_type !== r.new_advisory_type || r.old_advisory_text !== r.new_advisory_text) {
      const oldAdv = r.old_advisory_type ? `${r.old_advisory_type}` : 'None'
      const newAdv = r.new_advisory_type ? `${r.new_advisory_type}` : 'None'
      const change = oldAdv !== newAdv
        ? `${oldAdv} → ${newAdv}`
        : `${newAdv} (text updated)`
      const detail = r.new_advisory_text || r.reason || '—'
      statusHistoryRows.push([time, 'Advisory', change, name, detail])
    }
  }

  // BWC changes from inspections
  for (const insp of data.inspections) {
    if (insp.bwc_value) {
      const time = insp.completed_at ? fmtTime(insp.completed_at) : ''
      const name = insp.completed_by_name || insp.inspector_name || 'Unknown'
      statusHistoryRows.push([time, 'BWC', insp.bwc_value, name, '—'])
    }
  }

  // RSC changes from RSC checks
  const rscChecks = data.checks.filter((c) => c.check_type === 'rsc')
  for (const c of rscChecks) {
    const time = c.completed_at ? fmtTime(c.completed_at) : ''
    const d = c.data as Record<string, unknown>
    const condition = (d?.condition as string) || (d?.runway_condition as string) || 'Reported'
    const detail = [
      d?.contaminant ? `Contaminant: ${d.contaminant}` : '',
      d?.braking_action ? `Braking: ${d.braking_action}` : '',
      d?.treatment ? `Treatment: ${d.treatment}` : '',
    ].filter(Boolean).join(', ') || '—'
    statusHistoryRows.push([time, 'RSC', condition, c.completed_by || 'Unknown', detail])
  }

  if (statusHistoryRows.length === 0) {
    emptyState('No status changes recorded for this date.')
  } else {
    // Sort by time
    statusHistoryRows.sort((a, b) => a[0].localeCompare(b[0]))

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['Time', 'Category', 'Change', 'Changed By', 'Details']],
      body: statusHistoryRows,
      styles: { fontSize: 8, cellPadding: 2, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      columnStyles: {
        0: { cellWidth: 20 },
        1: { cellWidth: 25 },
      },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // ── 4. NEW DISCREPANCIES ──
  sectionHeader(`NEW DISCREPANCIES (${data.newDiscrepancies.length})`)

  if (data.newDiscrepancies.length === 0) {
    emptyState('No new discrepancies reported for this date.')
  } else {
    const tableBody = data.newDiscrepancies.map((d) => {
      const reporter = d.reporter_rank ? `${d.reporter_rank} ${d.reporter_name}` : d.reporter_name
      return [d.display_id, d.title, formatDiscrepancyType(d.type), d.location_text, d.assigned_shop || '—', reporter, '']
    })

    const discPhotos = data.newDiscrepancies.map((d) => data.photos[`discrepancy:${d.id}`] || [])

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['ID', 'Title', 'Type', 'Location', 'Shop', 'Reported By', 'Photos']],
      body: tableBody,
      styles: { fontSize: 7, cellPadding: 1.5, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      columnStyles: {
        0: { cellWidth: 22 },
        1: { cellWidth: 32 },
        6: { cellWidth: 48 },
      },
      didParseCell: (hookData) => {
        if (hookData.section === 'body') {
          const photos = discPhotos[hookData.row.index] || []
          if (photos.length > 0) {
            hookData.cell.styles.minCellHeight = PHOTO_THUMB_H + 4
          }
        }
      },
      didDrawCell: (hookData) => {
        if (hookData.section === 'body' && hookData.column.index === 6) {
          const photos = discPhotos[hookData.row.index] || []
          drawPhotosInCell(doc, photos, hookData.cell.x, hookData.cell.y, hookData.cell.width)
        }
      },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // ── 5. UPDATED DISCREPANCIES ──
  const uniqueUpdatedDiscs = new Set(data.statusUpdates.map((u) => u.discrepancy_id))
  sectionHeader(`DISCREPANCY UPDATES (${data.statusUpdates.length} update${data.statusUpdates.length !== 1 ? 's' : ''} across ${uniqueUpdatedDiscs.size} discrepanc${uniqueUpdatedDiscs.size !== 1 ? 'ies' : 'y'})`)

  if (data.statusUpdates.length === 0) {
    emptyState('No discrepancy updates for this date.')
  } else {
    const tableBody = data.statusUpdates.map((u) => {
      const statusChange = u.old_status && u.new_status
        ? `${STATUS_LABELS[u.old_status] || u.old_status} → ${STATUS_LABELS[u.new_status] || u.new_status}`
        : u.new_status ? STATUS_LABELS[u.new_status] || u.new_status : '—'
      const name = u.user_rank ? `${u.user_rank} ${u.user_name}` : u.user_name
      return [u.discrepancy_display_id, u.discrepancy_title, statusChange, u.notes || '—', name, fmtTime(u.created_at)]
    })

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['ID', 'Title', 'Status Change', 'Notes', 'Updated By', 'Time']],
      body: tableBody,
      styles: { fontSize: 7, cellPadding: 1.5, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      columnStyles: {
        0: { cellWidth: 22 },
        3: { cellWidth: 35 },
      },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // ── 6. OBSTRUCTION EVALUATIONS ──
  sectionHeader('OBSTRUCTION EVALUATIONS')

  if (data.obstructionEvals.length === 0) {
    emptyState('No obstruction evaluations recorded for this date.')
  } else {
    const tableBody = data.obstructionEvals.map((e) => {
      const result = e.has_violation ? 'VIOLATION' : 'CLEAR'
      const name = e.evaluator_rank ? `${e.evaluator_rank} ${e.evaluator_name}` : e.evaluator_name
      const surfaces = e.has_violation ? (e.violated_surfaces || []).length.toString() : '—'
      return [e.display_id, e.description || '—', `${e.object_height_agl} ft AGL`, result, e.controlling_surface || '—', surfaces, name, '']
    })

    const obsPhotos = data.obstructionEvals.map((e) => data.photos[`obstruction:${e.id}`] || [])

    autoTable(doc, {
      startY: y,
      margin: { left: margin, right: margin },
      head: [['ID', 'Description', 'Height', 'Result', 'Ctrl Surface', 'Viol.', 'Evaluated By', 'Photos']],
      body: tableBody,
      styles: { fontSize: 7, cellPadding: 1.5, textColor: [0, 0, 0] },
      headStyles: { fillColor: [30, 41, 59], textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 7 },
      alternateRowStyles: { fillColor: [245, 245, 245] },
      columnStyles: {
        7: { cellWidth: 48 },
      },
      didParseCell: (hookData) => {
        if (hookData.section !== 'body') return
        // Highlight VIOLATION in red
        if (hookData.column.index === 3) {
          const val = hookData.cell.raw as string
          if (val === 'VIOLATION') {
            hookData.cell.styles.textColor = [220, 38, 38]
            hookData.cell.styles.fontStyle = 'bold'
          }
        }
        // Set row height for photos (applied to ALL cells so the entire row expands)
        const photos = obsPhotos[hookData.row.index] || []
        if (photos.length > 0) {
          hookData.cell.styles.minCellHeight = PHOTO_THUMB_H + 4
        }
      },
      didDrawCell: (hookData) => {
        if (hookData.section === 'body' && hookData.column.index === 7) {
          const photos = obsPhotos[hookData.row.index] || []
          drawPhotosInCell(doc, photos, hookData.cell.x, hookData.cell.y, hookData.cell.width)
        }
      },
    })
    y = (doc as unknown as { lastAutoTable: { finalY: number } }).lastAutoTable.finalY + 4
  }

  // Footer
  addPageNumber()

  // Save
  const dateSuffix = opts.isRange
    ? `${opts.startDate}_to_${opts.endDate}`
    : opts.startDate
  doc.save(`KMTC_Daily_Ops_${dateSuffix}.pdf`)
}

// ── Photo rendering helper ──

const PHOTO_THUMB_W = 20 // mm
const PHOTO_THUMB_H = 15 // mm (4:3 ratio)
const PHOTO_GAP = 1.5 // mm

function drawPhotosInCell(
  doc: jsPDF,
  photos: PhotoForDailyReport[],
  cellX: number,
  cellY: number,
  cellWidth: number,
) {
  if (photos.length === 0) return

  const padding = 2
  const availableWidth = cellWidth - padding * 2
  const thumbsPerRow = Math.max(1, Math.floor(availableWidth / (PHOTO_THUMB_W + PHOTO_GAP)))
  let xOffset = cellX + padding
  let yOffset = cellY + padding

  for (let i = 0; i < photos.length; i++) {
    if (i > 0 && i % thumbsPerRow === 0) {
      yOffset += PHOTO_THUMB_H + PHOTO_GAP
      xOffset = cellX + padding
    }

    const photo = photos[i]
    if (photo.dataUrl) {
      try {
        const format = photo.dataUrl.includes('image/png') ? 'PNG' : 'JPEG'
        doc.addImage(photo.dataUrl, format, xOffset, yOffset, PHOTO_THUMB_W, PHOTO_THUMB_H)
      } catch {
        // Draw placeholder on failure
        doc.setDrawColor(180)
        doc.rect(xOffset, yOffset, PHOTO_THUMB_W, PHOTO_THUMB_H)
        doc.setFontSize(5)
        doc.setTextColor(150)
        doc.text('img', xOffset + 2, yOffset + PHOTO_THUMB_H / 2)
      }
    } else {
      // No data URL — show placeholder
      doc.setDrawColor(180)
      doc.rect(xOffset, yOffset, PHOTO_THUMB_W, PHOTO_THUMB_H)
      doc.setFontSize(5)
      doc.setTextColor(150)
      doc.text('img', xOffset + 2, yOffset + PHOTO_THUMB_H / 2)
    }

    xOffset += PHOTO_THUMB_W + PHOTO_GAP
  }
}
